#!/bin/bash

# ARG_OPTIONAL_SINGLE([venv-name],[n],[Specify the name of the virtual environment],[cims-env])
# ARG_OPTIONAL_BOOLEAN([jupyter],[j],[Launch Jupyter Lab],[on])
# ARG_OPTIONAL_BOOLEAN([update],[s],[Update Python dependencies in existing virtual environment],[on])
# ARG_HELP([This script sets up a CIMS virtual environment, installs any required dependencies, and launches a modeling notebook in Jupyter Lab.])
# ARG_VERSION([echo setup.sh 1.0])
# ARG_DEFAULTS_POS([])
# ARG_DEFAULTS_POS([])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='njshv'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_venv_name="cims-env"
_arg_jupyter="on"
_arg_update="on"


print_help()
{
	printf '%s\n' "This script sets up a CIMS virtual environment, installs any required dependencies, and launches a modeling notebook in Jupyter Lab."
	printf 'Usage: %s [-n|--venv-name <arg>] [-j|--(no-)jupyter] [-s|--(no-)update] [-h|--help] [-v|--version]\n' "$0"
	printf '\t%s\n' "-n, --venv-name: Specify the name of the virtual environment (default: 'cims-env')"
	printf '\t%s\n' "-j, --jupyter, --no-jupyter: Launch Jupyter Lab (on by default)"
	printf '\t%s\n' "-s, --update, --no-update: Update Python dependencies in existing virtual environment (on by default)"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\t%s\n' "-v, --version: Prints version"
}


parse_commandline()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-n|--venv-name)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_venv_name="$2"
				shift
				;;
			--venv-name=*)
				_arg_venv_name="${_key##--venv-name=}"
				;;
			-n*)
				_arg_venv_name="${_key##-n}"
				;;
			-j|--no-jupyter|--jupyter)
				_arg_jupyter="on"
				test "${1:0:5}" = "--no-" && _arg_jupyter="off"
				;;
			-j*)
				_arg_jupyter="on"
				_next="${_key##-j}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-j" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-s|--no-update|--update)
				_arg_update="on"
				test "${1:0:5}" = "--no-" && _arg_update="off"
				;;
			-s*)
				_arg_update="on"
				_next="${_key##-s}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-s" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			-v|--version)
				echo setup.sh 1.0
				exit 0
				;;
			-v*)
				echo setup.sh 1.0
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

MIN_PYTHON=(3,9)

set -e
set -o pipefail

# Formatting
RED='\e[0;31m'    # Red
LBLUE='\e[0;36m'  # Light Blue
LGRN='\e[0;92m'   # LIGHT GREEN
YLW="\e[0;33m"   # Yellow
NC='\e[0m'        # No Color
LBLUE='\e[0m'  # Light Blue

# Function to print colored messages to stderr
print_color() {
    local MSG=$1
    local COLOR=$2
    local no_color=${NO_COLOR:-false}
    if $no_color; then
        printf "${MSG}"
    else
        printf "${COLOR}${MSG}${NC}"
    fi

}

# Function to compare Python versions
check_python_version() {
    local python_path=$1
    $python_path -c "import sys; assert sys.version_info >= (${MIN_PYTHON})" 2>/dev/null
}

# Function to create virtual environment
create_virtual_env() {
    # Find locations of python3 installations which satisfy the minimum required Python version
    local options=()
    local i=0
    IFS=':' read -r -a dirs <<< "$PATH"
    for dir in "${dirs[@]}"; do
        if [ -d "$dir" ]; then
            while IFS= read -r -d $'\0' f; do
                if check_python_version "$f"; then options[i++]="$f"; fi
            done < <(find "$dir" -regex ".*/python3\.[0-9]*" -maxdepth 1 -print0)
        fi
    done

    # Sort the list of Python versions in descending order
    IFS=$'\n' sorted_options=($(sort -rV <<<"${options[*]}"))
    unset IFS

    # Pre-select the most recent Python version
    local recommended_python="${sorted_options[0]}"

    # Create a selection menu of options with recommended message
    local prompt
    prompt=$(printf "${YLW}Select an installed version of Python to use in your virtual environment: $NC")
    PS3="${prompt}"
    local options_with_recommendation=()
    for option in "${sorted_options[@]}"; do
        version=$(basename "$option")
        if [[ "$option" == "$recommended_python" ]]; then
            options_with_recommendation+=("${version} (${option}) - RECOMMENDED")
        else
            options_with_recommendation+=("${version} (${option})")
        fi
    done

    select SELECTED_PYTHON in "${options_with_recommendation[@]}" "I'll install another Python version"; do
        if [[ "$REPLY" -eq $((${#options_with_recommendation[@]} + 1)) ]]; then
            local py_prompt=$(echo "$MIN_PYTHON" | sed 's/,/./')
            print_color "Please install Python >= ${py_prompt} and rerun this script.\n" "$RED"
            exit 0
        fi
        SELECTED_PYTHON=$(echo "$SELECTED_PYTHON" | sed 's/ - RECOMMENDED//' | sed 's/.*(\(.*\)).*/\1/')
        print_color "Selected ${SELECTED_PYTHON}\n" "$LGRN"
        break
    done

    print_color "Building ${_arg_venv_name}..." "$LBLUE"
    "$SELECTED_PYTHON" -m venv "${_arg_venv_name}"
    print_color "DONE\n" "$LGRN"
}

# Step 1: Setup Virtual Environment
print_color "Checking for ${_arg_venv_name} virtual environment..." "$LBLUE"
if [ -d "${_arg_venv_name}" ]; then
    CREATE_NEW_ENV=false
    print_color "FOUND\n" "$LGRN"
else
    CREATE_NEW_ENV=true
    print_color "NOT FOUND\n" "$LBLUE"
    print_color "Creating ${_arg_venv_name} virtual environment...\n" "$YLW"
    create_virtual_env
fi

# Step 2: Activate the virtual environment
print_color "Activating ${_arg_venv_name} virtual environment..." "$LBLUE"
source "${_arg_venv_name}/bin/activate"
print_color "DONE\n" "$LGRN"

# Step 3: Install dependencies
if [ "$CREATE_NEW_ENV" = true ]; then
    print_color "Installing dependencies..." "$LBLUE"
    pip install -q --upgrade pip
    pip install -q -r requirements.txt
    print_color "DONE\n" "$LGRN"
elif [ "$_arg_update" = "on" ]; then
    print_color "Updating dependencies..." "$LBLUE"
    pip install -q --upgrade pip
    pip install -q -r requirements.txt
    print_color "DONE\n" "$LGRN"
fi

# Step 4: Launch JupyterLab (if not disabled)
if [ "$_arg_jupyter" = "on" ]; then
    print_color "Launching JupyterLab...Use Ctrl+C to exit\n" "$LBLUE"
    jupyter lab --log-level=40 ./scenarios/Reference.ipynb
    print_color "Closing Jupyter Lab..." "$LBLUE"
	print_color "DONE\n" "$LGRN"
fi

# Deactivate the virtual environment
print_color "Deactivating ${_arg_venv_name} virtual environment..." "$LBLUE"
deactivate
print_color "DONE\n" "$LGRN"

# Exit with a success code
exit 0

# ] <-- needed because of Argbash